{"version":3,"sources":["webpack:///./src/api/modules/auth.js","webpack:///./src/server.js","webpack:///external \"express-jwt\"","webpack:///external \"jsonwebtoken\""],"names":["jwtSecret","checkToken","expressJwt","secret","disableAuth","signin","req","res","next","token","signToken","user","id","json","decodeToken","query","hasOwnProperty","headers","authorization","access_token","getFreshUser","User","findById","then","status","send","catch","error","verifyUser","username","body","password","findOne","authenticate","err","jwt","sign","expiresIn","protect","app","express","use","bodyParser","extended","cors","restRouter","all"],"mappings":"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","file":"0.163f505d3f0bb6de2ba8.hot-update.js","sourcesContent":["import { User } from '../resources/user/user.model'\nimport jwt from 'jsonwebtoken'\nimport expressJwt from 'express-jwt'\n\n// remove? change?\nconst jwtSecret = 'blueRhinoJumps'\n\nconst checkToken = expressJwt({ secret: jwtSecret })\nconst disableAuth = false\n\nexport const signin = (req, res, next) => {\n  // req.user will be there from the middleware\n  // verify user. Then we can just create a token\n  // and send it back for the client to consume\n  const token = signToken(req.user.id)\n  res.json({ token: token })\n}\n\nexport const decodeToken = () => (req, res, next) => {\n  if (disableAuth) {\n    return next()\n  }\n  // make it optional to place token on query string\n  // if it is, place it on the headers where it should be\n  // so checkToken can see it. See follow the 'Bearer 034930493' format\n  // so checkToken can see it and decode it\n  if (req.query && req.query.hasOwnProperty('access_token')) {\n    req.headers.authorization = 'Bearer ' + req.query.access_token\n  }\n\n  // this will call next if token is valid\n  // and send error if its not. It will attached\n  // the decoded token to req.user\n  checkToken(req, res, next)\n}\n\nexport const getFreshUser = () => (req, res, next) => {\n  return User.findById(req.user.id)\n    .then(function (user) {\n      if (!user) {\n        // if no user is found it was not\n        // it was a valid JWT but didn't decode\n        // to a real user in our DB. Either the user was deleted\n        // since the client got the JWT, or\n        // it was a JWT from some other source\n        res.status(401).send('Unauthorized')\n      } else {\n        // update req.user with fresh user from\n        // stale token data\n        req.user = user\n        next()\n      }\n    })\n    .catch(error => next(error))\n}\n\nexport const verifyUser = () => (req, res, next) => {\n  const username = req.body.username\n  const password = req.body.password\n\n  // if no username or password then send\n  if (!username || !password) {\n    res.status(400).send('You need a username and password')\n    return\n  }\n\n  // look user up in the DB so we can check\n  // if the passwords match for the username\n  User.findOne({ username: username })\n    .then(function (user) {\n      if (!user) {\n        res.status(401).send('No user with the given username')\n      } else {\n        // checking the passowords here\n        if (!user.authenticate(password)) {\n          res.status(401).send('Wrong password')\n        } else {\n          // if everything is good,\n          // then attach to req.user\n          // and call next so the controller\n          // can sign a token from the req.user._id\n          req.user = user;\n          next()\n        }\n      }\n    })\n    .catch(error => next(err))\n}\n\nexport const signToken = (id) => jwt.sign(\n  { id },\n  jwtSecret,\n  { expiresIn: '30d' }\n)\n\nexport const protect = [decodeToken(), getFreshUser()]\n\n\n// WEBPACK FOOTER //\n// ./src/api/modules/auth.js","import express from 'express'\nimport setupMiddleware from './middleware'\nimport { restRouter } from './api'\nimport { connect } from './db'\nimport { signin, protect } from './api/modules/auth'\nimport cors from 'cors'\nimport bodyParser from 'body-parser'\nconst app = express()\n\napp.use(bodyParser({ extended: true }))\napp.use(cors())\napp.use('/api', restRouter)\n\napp.all('*', (req, res) => {\n  res.json({\n    error: \"Use /api/notes to get all notes or post a note, \"\n      + \"otherwise use /api/notes/:id to update, get or delete a single note\"\n  })\n})\n\nexport default app\n\n\n\n// WEBPACK FOOTER //\n// ./src/server.js","module.exports = require(\"express-jwt\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"express-jwt\"\n// module id = express-jwt\n// module chunks = 0","module.exports = require(\"jsonwebtoken\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jsonwebtoken\"\n// module id = jsonwebtoken\n// module chunks = 0"],"sourceRoot":""}