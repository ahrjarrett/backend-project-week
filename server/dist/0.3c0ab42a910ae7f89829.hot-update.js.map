{"version":3,"sources":["webpack:///./src/api/modules/auth.js","webpack:///./src/api/resources/user/user.model.js","webpack:///external \"bcrypt\""],"names":["jwtSecret","checkToken","expressJwt","secret","disableAuth","signin","req","res","next","token","signToken","user","id","json","decodeToken","query","hasOwnProperty","headers","authorization","access_token","getFreshUser","User","findById","then","status","send","catch","error","verifyUser","username","body","password","findOne","authenticate","err","jwt","sign","expiresIn","protect","schema","userSchema","mongoose","Schema","timestamps","methods","plainTextPassword","bcrypt","compareSync","hashPassword","Error","salt","genSaltSync","hashSync","model"],"mappings":"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","file":"0.3c0ab42a910ae7f89829.hot-update.js","sourcesContent":["import { User } from '../resources/user/user.model'\nimport jwt from 'jsonwebtoken'\nimport expressJwt from 'express-jwt'\n\n// remove? change?\nconst jwtSecret = 'blueRhinoJumps'\n\nconst checkToken = expressJwt({ secret: jwtSecret })\nconst disableAuth = false\n\nexport const signin = (req, res, next) => {\n  // req.user will be there from the middleware\n  // verify user. Then we can just create a token\n  // and send it back for the client to consume\n  const token = signToken(req.user.id)\n  res.json({ token: token })\n}\n\nexport const decodeToken = () => (req, res, next) => {\n  if (disableAuth) {\n    return next()\n  }\n  // make it optional to place token on query string\n  // if it is, place it on the headers where it should be\n  // so checkToken can see it. See follow the 'Bearer 034930493' format\n  // so checkToken can see it and decode it\n  if (req.query && req.query.hasOwnProperty('access_token')) {\n    req.headers.authorization = 'Bearer ' + req.query.access_token\n  }\n\n  // this will call next if token is valid\n  // and send error if its not. It will attached\n  // the decoded token to req.user\n  checkToken(req, res, next)\n}\n\nexport const getFreshUser = () => (req, res, next) => {\n  return User.findById(req.user.id)\n    .then(function (user) {\n      if (!user) {\n        // if no user is found it was not\n        // it was a valid JWT but didn't decode\n        // to a real user in our DB. Either the user was deleted\n        // since the client got the JWT, or\n        // it was a JWT from some other source\n        res.status(401).send('Unauthorized')\n      } else {\n        // update req.user with fresh user from\n        // stale token data\n        req.user = user\n        next()\n      }\n    })\n    .catch(error => next(error))\n}\n\nexport const verifyUser = () => (req, res, next) => {\n  const username = req.body.username\n  const password = req.body.password\n\n  // if no username or password then send\n  if (!username || !password) {\n    res.status(400).send('You need a username and password')\n    return\n  }\n\n  // look user up in the DB so we can check\n  // if the passwords match for the username\n  User.findOne({ username: username })\n    .then(function (user) {\n      if (!user) {\n        res.status(401).send('No user with the given username')\n      } else {\n        // checking the passowords here\n        if (!user.authenticate(password)) {\n          res.status(401).send('Wrong password')\n        } else {\n          // if everything is good,\n          // then attach to req.user\n          // and call next so the controller\n          // can sign a token from the req.user._id\n          req.user = user;\n          next()\n        }\n      }\n    })\n    .catch(error => next(err))\n}\n\nexport const signToken = (id) => jwt.sign(\n  { id },\n  jwtSecret,\n  { expiresIn: '30d' }\n)\n\nexport const protect = [decodeToken(), getFreshUser()]\n\n\n// WEBPACK FOOTER //\n// ./src/api/modules/auth.js","import mongoose from 'mongoose'\nimport bcrypt from 'bcrypt'\n\nexport const schema = {\n\n}\n\nconst userSchema = new mongoose.Schema(schema, { timestamps: true })\n\nuserSchema.methods = {\n  authenticate(plainTextPassword) {\n    return bcrypt.compareSync(plainTextPassword, this.password)\n  },\n  hashPassword(plainTextPassword) {\n    if (!plainTextPassword) {\n      throw new Error('Could not save user')\n    }\n\n    const salt = bcrypt.genSaltSync(10)\n    return bcrypt.hashSync(plainTextPassword, salt)\n  }\n}\n\nexport const User = mongoose.model('user', userSchema)\n\n\n\n// WEBPACK FOOTER //\n// ./src/api/resources/user/user.model.js","module.exports = require(\"bcrypt\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bcrypt\"\n// module id = bcrypt\n// module chunks = 0"],"sourceRoot":""}